\documentclass[italian]{memoir}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{minted}
\usepackage{xcolor}
\usepackage{color}
\usepackage{tcolorbox}

\usepackage{titlesec}

\graphicspath{{./draws/}}

%\title{How to write a Report\\ for the Project of Distributed Systems}
\title{Progetto di Sistemi Distribuiti}

\author{Borsoi Diego - n°129804\\Callegari Filippo -  n°128602\\ DMIF, University of Udine,
	   Italy\\(also the authors are distributed)}

\date{\today}

\begin{document}

\pagenumbering{gobble}
\maketitle
\newpage

\pagenumbering{alph}
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			prefazione    		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}


\chapter{Introduzione}\label{ch:intro}

Il progetto in questione riguarda la creazione di un sistema distribuito per la comunicazione
	   fra dispositivi all'interno di una rete sparsa, tramite l'utilizzo di eventi.

\section{Descrizione del problema}

Ogni dispositivo corrisponde ad un nodo della rete ed è caratterizzato da:
\begin{itemize}
\item \textbf{Id} : numero univoco del nodo.
\item \textbf{Stato} : tupla di variabili che rappresentano delle specifiche caratteristiche
	   del nodo (es. temperatura di un sensore, stato di accensione di una termocoppia,
	   ecc).
\item \textbf{Regole} : insieme di regole del tipo ECA (Event Condition Action) che
	   possono attivarsi a seguito di un evento inviato al nodo. Queste regole possono
	   essere
	   di tre tipi: locali, l'azione modifica solamente lo stato del nodo in cui si
	   attiva,
	   globale, l'azione viene inviata a tutti i nodi della rete perché venga
	   letta
	   ed, in caso la valutazione della guardia associata sia positiva, eseguita, oppure di transazione, dove l'azione associata verrà eseguita da tutti i nodi partecipanti contemporaneamente.
\center$\{event;~condition;~action~|~\text{if}~guard~\text{then}~action\}$
\end{itemize}

Lo stato della rete si evolverà ogni qual volta un evento verrà attivato, andando
	   a sua volta ad innescare eventuali nuovi eventi e creando quindi una sequenza
	   di
	   azioni a cascata.

\section{Struttura dell'implementazione}

La rete in questione ha una struttura a mesh sparsa (cioè ogni nodo sarà al più
	   connesso a un numero di nodi molto basso, rispetto alla totalità).
I nodi sono idempotenti in modo tale da avere un sistema fortemente decentralizzato.
Le varie comunicazioni fra i nodi sono eseguite al di sopra di connessioni TCP, in
	   tal modo possiamo garantire la consegna di ogni messaggio nell'ordine prestabilito.
Per quanto concerne invece le comunicazioni riguardanti il sistema di $heartbeat$
	   (\ref{heartbeat}), queste vengono eseguite utilizzando connessioni UDP.

\section{Trasparenze}\label{Trasparenze}

Di seguito sono descritte le trasparenze che concergono e sono implementate dal sistema:

\begin{description} 
\item[Trasparenza ai fallimenti:] nel momento in cui un nodo fallisce/si disconnette,
	   il resto della rete continua a funzionare regolarmente, senza quindi avere delle interruzioni nel normale svolgimento degli eventi.
\item[Trasparenza alla scalabilità:] la rete può espandersi in dimensione senza
	   che il funzionamento dei nodi vari.
\item[Trasparenza alla mobilità:] un nodo può spostarsi all'interno della rete
	   senza che il funzionameto suo e degli altri nodi vada a modificarsi.
\end{description}

\section{Algoritmi}

Il sistema implementa solamente due algoritmi:
\begin{itemize}
\item \textbf{Flooding Algorithm:} viene usato inizialmente per la comunicazione di un'azione
	   a tutta la rete nel momento in cui in un nodo una regola globale o di transazione viene attivata.
\item \textbf{Lamport clock (modificato):} viene utilizzata una versione modificata
	   del Lamport clock per identificare i vari $flood$ eseguiti; questo clock viene
	   incrementato
	   solamente dall'invio (o ricezione) di un messasggio, e non dalle azioni interne
	   ad un nodo;
\item \textbf{Distributed Spanning Tree:} viene usato per ridurre il traffico di rete 
       quando la rete si è ``stabilizzata''. Questo algoritmo mira a creare un albero di
       copertura nella rete.
\end{itemize}

Il sistema non implementa particolari algoritmi essendo che si vuole realizzare una
	   rete distribuita dove ogni nodo conosce esclusivamente i vicini ed evolve il
	   suo
	   stato solamente a causa di eventi ricevuti tramite dei messaggi.

\section{Testing}

Per testare il sistema verrà utilizzata un'entità $Ambiente$, la quale simulerà:
	   
\begin{itemize}
\item la creazione iniziale della rete, caricando da dei file appositi la struttura
	   degli stati, la lista di regole e la conformazione della rete
\item la scoperta di nuove connessioni
\item variazioni di variabili legate all'ambiente (es. temperatura registrata da
	   un sensore)
\item fallimenti di nodi
\item ritardi nell'invio di messaggi fra nodi
\end{itemize}

Ogni modulo verrà testato singolarmente ed infine verranno eseguiti dei test completi
	   del sistema.

\section{Piano di sviluppo}

Le future fasi di sviluppo seguiranno il seguente ordine:
\begin{enumerate}
\item Riunione con il committente per convalidare la risoluzione del problema
\item Implementazione ambiente virtuale per la gestione dei nodi 
\item Implementazione della struttura del nodo
\item Implementazione sistema $heartbeat$
\item Implementazione del sistema algoritmico
\item Test totale
\item Validazione
\end{enumerate}


%\section{Istruzioni}
%In this chapter you describe the main problem, and an idea of the solution.
%It is not necessary to be very detailed or formal, but it is important to explain
%	   which are the main aims and issues from the point of view of Distributed Systems:
%\begin{itemize}
%\item A description of the application.
%\item The overall structure of the implementation: how resources are deployed, which
%	   are the players, the r\^oles.
%\item The distributed system features (and the transparencies) and algorithms you
%	   intend to implement.
%\item Your plan for testing the system.
%\item A schedule for how you plan to carry out your design and implementation
%\end{itemize}

\chapter{Analisi}\label{ch:analisi}

In questo capitolo vengono descritti nel dettaglio requisiti funzionali e non funzionali
	   della soluzione proposta.

\section{Requisiti Funzionali}\label{sec:funcReq}

I requisiti funzionali individuati sono:
\begin{itemize}
\item \textbf{Categorizzazione di un nodo:} ogni nodo ha un tipo il quale ne identifica
	   lo stato e le sue regole;
\item \textbf{Modifica delle regole di un nodo:} ogni tipo di nodo può avere le
	   sue regole, codificabili attraverso la programmazione dello stesso;
\item \textbf{Modifica dello stato di un nodo:} ogni evento permette di avere o degli
	   \textit{effetti locali}, degli \textit{effetti globali} o degli \textit{effetti transizionali}:
	\begin{itemize}
	\item \textit{\textbf{effetti locali}}: la regola va a modificare lo stato interno;
	\item \textit{\textbf{effetti globali}}: la regola può modificare lo stato delle
	   variabili interne, e può generare un evento sugli altri nodi;
	\item \textit{\textbf{effetti transizionali}}: regola simile a quelle globali, ma con la differenza
	   che l'esecuzione avverrà in tutti i nodi coinvolti ``contemporaneamente'';
	\end{itemize}
\item \textbf{Aggiunta dinamica di un nodo:} un nodo può essere aggiunto alla rete
	   in qualsiasi momento senza perturbarne la dinamicità, limitando l'aggiornamento
	   ai vicini a cui si collega.
\item \textbf{Esecuzione di un'azione ricevuta dai vicini:} nel momento in cui un
	   nodo riceve un messaggio dai propri vicini esso va a verificare la soddisfacibilità
	   della guardia (se presente) e nel caso di una valutazione positiva viene eseguita
	   l'azione associata, andando quindi a modificare il proprio stato.
\item \textbf{Attivazione di una regola:} ogni qual volta avviene un cambiamento
	   nello stato di un nodo, viene eseguito un controllo delle regole, per vedere
	   se gli
	   eventi generati possano attivare una o più regole del nodo; nel caso in cui
	   una regola venga attivata, in base al tipo (locale, globale o transazione) viene portata a termine
	   l'azione corrispondente.
\end{itemize}

\section{Requisiti Non Funzionali}

I requisiti non funzionali individuati sono:
\begin{itemize}
\item \textbf{Decentralizzazione:} nessun nodo ha il controllo dell'ordine degli
	   eventi, grazie al fatto che ogni nodo è idempotente;
\item \textbf{Tolleranza ai guasti:} poiché tutti i nodi sono idempotenti, nel momento
	   in cui un nodo si scollega dalla rete, la rete rimanente continua ad operare
	   normalmente;
\item \textbf{Etereogenità:} fintanto che i nodi aggiunti utilizzano il protocollo
	   descritto, qualunque nodo di qualunque tipo (hardware o categoria) potrà essere
	   aggiunto alla rete;
\item \textbf{Scalabilità:} l'aggiunta dinamica dei nodi alla rete permette di scalare
	   orizzontalmente con estrema facilità;
\item \textbf{Trasparenze:} le trasparenze implementate sono quelle descritte al
	   capitolo precedente (paragrafo \ref{Trasparenze}).
\end{itemize}

%\chapter{Analysis}\label{ch:analysis}
%
%In this chapter, we describe in detail functional and non-functional requirements
%	   of a solution for the problem.
%
%\section{Functional requirements}
%Which functions must be offered to users / other programs?  Which are the input
%	   data and the output data? Which is the expected effect? 
%
%\section{Non functional requirements}
%Everything about mode and transparencies: availability, mobility, security, fault
%	   tolerance, etc.
%
%Are there execution time bounds? Minimum data rates?
%
%If requested, specific platforms/languages/middlewares requirements for the implementation
%	   can be decided here. (E.g.: if the project is on a SOA, we may request that
%	   functions
%	   are offered via SOAP or RESTful services). 



\chapter{Progetto}\label{ch:progetto}

In questo capitolo vengono descritti in modo più approfondito l'achitettura del
	   progetto, i moduli, i protocolli e gli algoritmi utilizzati.

\section{Architettura logica}

Essendo tutti i nodi costruiti al medesimo modo, di seguito presentiamo la struttura
	   di uno singolo di essi. 

\begin{figure}[H]
\makebox[\linewidth][c]{\includegraphics[scale=0.65]{draw_nodeworker.pdf}}
%\includegraphics[scale=0.6]{draw_nodeworker.pdf}
%\centering
\caption{Struttura gerarchica dei moduli di un nodo e visualizzazione delle connessioni
	   fra di essi.}
\label{img:struttura_nodo}
\end{figure}

Come si può vedere dalla figura \ref{img:struttura_nodo}, ogni nodo è formato dai
	   seguenti moduli:
\begin{itemize}
	\item \textbf{Supervisor nodo:} modulo che cerca di manterene sempre operativi gli
	   altri moduli interni. Se questo componente si riavvia equivarrebbe ad un riavvio
	   del nodo, e quindi la conseguente perdita della modifica agli stati interni.
	   I moduli
	   da lui controllati sono:
	\begin{itemize}
	\item \textbf{State server:} questo modulo manterrà tutte le variabili locali al
	   nodo, che verranno modificate durante l'operatività dello stesso. Queste variabili
	   sono:
		\begin{itemize}
		\item stato del nodo;
		\item lista delle regole associate al nodo;
		\item tipo del nodo;
		\item stato delle waves; %sia clock che cose precedenti
		\item informazioni sui nodi vicini;
		\item id univoco del nodo;
		\end{itemize}
	\item \textbf{Supervisor dei workers:} modulo che si occupa di gestire i moduli
	   a lui dipendenti, riavviandoli in caso di ``crash''. Questi sono:
		\begin{itemize}
		\item \textbf{heartbeat sense:} si occupa di controllare la ``vitalità'' dei vicini,
	     di istanziare le connessioni con essi e di mantenere la ``spanning tree'' della rete.
	     Ogni qual volta che deve comunicare con dei vicini affini, creerà un processo effimero
	     (HB\_out);
		\item \textbf{communication in:} si occupa di gestire tutti i messaggi in ingresso
	   relativi al nodo in questione;
		\item \textbf{rules worker:} si occupa di applicare le azioni ricevute dai nodi
	   vicini ed eventualmente eseguire una delle regole a lui locali al momento dell'attivazione;
	   lui si occuperà anche di propagare le regole che generano degli eventi verso
	   gli
	   altri nodi, interpellando il modulo ``\textit{communication out}'' 
	  (modulo apposito per l'invio dei messaggi ai nodi vicini).
		\end{itemize}
	\end{itemize}
\end{itemize}

Come è stato accennato in precedenza verrà sviluppato un ulteriore modulo chiamato
``\textbf{\textit{Ambiente}}'': questo modulo permette di simulare le interazioni
	   che avverrebbero nel mondo reale. Nel dettaglio, le funzionalità del modulo
	   sono:
\begin{itemize}
	\item il ``discovery'' dei vicini;
	\item cambiamento delle variabili non dipendenti dalle regole (temperatura dell'ambiente/GPS/...);
	\item simulazioni di disservizi di rete;
	\item simulazione di guasti (temporanei o non) di un nodo;
	\item topologia della rete.
\end{itemize}
Dal punto di vista del nodo ci troviamo quindi costretti ad aggiungere un ulteriore
	   modulo fittizio (\textbf{\textit{comunicazione ambiente}}) per permettere la
	   comunicazione
	   con l'ambiente.

\section{Protocolli ed algoritmi}

Di seguito verranno descriti nel dettaglio i vari protocolli ed algoritmi utilizzati.

\subsection{Controllo e attivazione delle regole}

Nel momento in cui il sistema riceve un'azione da eseguire (dopo aver controllato la validità e che appartenga ad una wave non ancora ricevuta) si innesca la seguente serie di azioni:
\begin{enumerate}
\item il modulo \textit{communication IN} invia l'azione da eseguire al modulo \textit{rules worker};
\item quest'ultimo utilizza una funzione dello \textit{state server} per modificare lo stato del nodo in accordo all'azione ricevuta;
\item il \textit{rules worker} esegue quindi un controllo sulle regole andando ad identificare quali possono essere attivate dalla modifica appena eseguita;
\item per ciascuna regola che viene attivata viene testata la condizione e in caso di risultato positivo:
\begin{itemize}
\item se la regola è del tipo \textit{locale}, viene eseguita l'azione associata
\item se invece la regola è del tipo \textit{globale}, viene eseguita l'azione associata (in caso di guardia con valutazione positiva) e viene passata ad un processo di \textit{communication OUT}, istanziato appositamente, che genera una nuova wave di messaggi inviando ai vicini la nuova azione.
\end{itemize}
\end{enumerate}

\subsection{Heartbeat}\label{heartbeat}
Il protocollo di ``heartbeat'' serve per mantenere consistente lo stato dei vicini
	   di un nodo. Questo infatti controlla la loro vitalità e sarà componente chiave
	   per l'aggiunta di un nuovo nodo.

L'algoritmo si suddivide quindi in tre componenti:
\begin{itemize}
	\item \textit{ECHO}: similmente al protocollo ICMP, si fa una richiesta di echo
	   al vicino. Se questa ``\textit{ECHO\_RQS}'' andrà a buon fine, il primo nodo che
	   istanzia una richiesta di ``\textit{ECHO}'' richeverà un pacchetto di ``\textit{ECHO\_RPL}''.
	   Definiamo come $\tau$ il tempo che intercorre tra un messaggio di \textit{ECHO} ed
	   un'altro. Se un nodo non rispondesse entro $2\tau$ ad una \textit{ECHO\_RQS}, questo
	   verrà considerato come non più collegato. Ogni \textit{ECHO\_RPL} conterrà il clock
	   attuale del vicino.
	\item \textit{ADD\_NEW\_ND}: similmente al protocollo DHCP, nella fase di aggiunta
	   di un nodo alla rete, il nuovo nodo si annuncia al suo vicino ``fisico'', chiedendo
	   le informazioni essenziali per poter partecipare attivamente alla rete. Questo sarà
	   spiegato più in dettaglio nella prossima sezione.
	\item \textit{TREE\_STATE}: questa componente si focalizza sulla gestione dell'albero di copertura della rete.
	Sarà analizzato in dettaglio nei paragrafi successivi.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics{HeartbeatDiagram.pdf}
\caption{Sequence diagram dei messagi usati per il sistema di \textit{heartbeat}.}
\label{img:heartbeat}
\end{figure}

\subsection{Aggiunta di un nuovo nodo}
L'aggiunta di un nodo è una parte complicata del sistema: bisogna tener conto della
	   possibilità che la rete si partizioni. Questo si può verificare nel caso in cui
	   un nodo si riavvii. Il partizionamento della rete è visto come caso particolare
	   di aggiunta di un nodo alla rete.

L'aggiunta di un nuovo nodo si compone dei seguenti passi:
\begin{enumerate}
	\item \textit{ADD\_NEW\_ND}: il nuovo nodo manda la richiesta di aggiunta alla rete
	   a tutti i suoi vicini inviando il proprio id;
	\item \textit{ADD\_NEW\_NB}: il nodo che deve aggiungere il nuovo nodo risponde
	   con un messaggio contenente $(clock,id)$.
\end{enumerate}
A questo punto, una volta che per ogni vicino ho i suoi parametri di clock, i casi
	   possibili sono 2:
\begin{enumerate}
	\item \textbf{tutti i nodi hanno medesimo clock:} imposto il mio clock al clock
	   comune;
	\item \textbf{esiste un clock massimo:} imposto il mio clock al valore massimo,
	   e rispondo con \textit{UPD\_LMP} a tutti i miei vicini che non hanno il clock al
	   massimo. Questi a loro volta manderanno a tutti i loro vicini, con clock diverso
	   da quello scelto, il nuovo valore.
\end{enumerate}

\begin{figure}[H]
\makebox[\linewidth][c]{\includegraphics[scale=0.9]{NewNodeDiagram.pdf}}
\caption{Sequence diagram dei messagi usati per laggiunta di un nuovo nodo alla rete.}
\label{img:newnode}
\end{figure}

\subsection{Two-phases Rules (Transazioni)}
Questo è un protocollo definito come ``two-phases commit'', ovvero permette l'esecuzione in
contemporanea su più parti di almeno un'azione. Questo protocollo è stato modificato rispetto
l'originale, in quanto, non avendo l'obbligo di avere sempre uno stato consistente tra i nodi,
ci permette di semplificarlo. Le fasi sono quindi le seguenti:
\begin{enumerate}
    \item \textit{discovery}: troviamo tutti i nodi nella rete che sono interessati ad eseguire la
    transazione. Il nodo inizializzatore manda nella rete un messaggio di richiesta di transazione,
    il quale contiene delle condizioni per partecipare. Se un nodo è interessato, risponderà all'inizializzatore
    dicendogli di essere interessato.
    \item \textit{start}: il nodo inizializzatore darà inizio alla transazione per i nodi interessati.
\end{enumerate}
All'interno di questo protocollo, come possiamo vedere nell'immagine \ref{img:transazioni}, vengono tenuti dei timeout
di controllo, al fine di non rimanere bloccato nello stato di transizione: se un nodo decide di partecipare 
alla transazione, allora non potrà eseguire altre regole.

\begin{figure}[H]
\makebox[\linewidth][c]{\includegraphics[scale=0.9]{Transaction_diagram.pdf}}
\caption{Sequence diagram del protocollo adottato per le regole di transaction.}
\label{img:transazioni}
\end{figure}

\subsection{Algoritmo: Flooding} \label{alg:flooding}
Ogni qual volta si crea una regola che genera un evento ``globale'', ogni nodo spedirà
	   ai suoi vicini un messaggio contenenta un'azione da eseguire. Questi, una volta ricevuto,
	   aggiorneranno il loro ``wave count'' (tenuto dal clock, spiegato successivamente),
	   e passerà all'esecuzione dell'istruzione condizionata contenuto nel messaggio. Al
	   fine di evitar la presenza di messaggi vecchi nella rete, ogni messaggio conterrà
	   la coppia $(clock,id\_gen)$: questo verrà salvato localmente nel nodo ricevente,
	   e verrà mantenuto in memoria al fine di verificare se un messaggio ricevuto non
	   è già stato eseguito. Ogni nodo quindi spedirà una copia del messaggio a tutti
	   i suoi vicini (a patto non l'abbia già ricevuto in passato), meno a quello da cui
	   l'ha ricevuto. Queste strategie applicate faranno si che i messaggi circolanti nella
	   rete siano il minor numero possibile, e nell'eventuale creazioni di cicli nella rete,
	   dovuta alla topologia della stessa, siano soppressi alla prima occasione utile.

\begin{figure}[H]
\makebox[\linewidth][c]{\includegraphics[scale=0.8]{FloodDiagram.pdf}}
\caption{Sequence diagram dei messaggi usati per l'algoritmo di flooding.}
\label{img:flooding}
\end{figure}

\subsection{Algoritmo: Lamport modificato}
Il ``Clock di Lamport'' ci permette di dare una certa conseguenza temporale alle azioni.
	   Questo sarà un numero intero crescente, ed identificherà ogni wave generata. Alla
	   generazione di una wave ogni nodo userà il suo clock interno, incrementato, per
	   identificarla. Questo ci permette, come già abbiamo spiegato, di controllare la
	   propagazione dei messaggi. Sia quindi $Lmp_i$ il clock della nuova wave ricevuta
	   e $Lmp_n$ il clock del nodo corrente. Le azioni intraprendibili sono:
\begin{itemize}
	\item $Lmp_i = Lmp_n + 1$: eseguo immediatamente l'azione in essa contenuta ed aggiorno
	   il valore di $Lmp_n$;
	\item $Lmp_i > Lmp_n + 1$: aspetto un preimpostato timeout (es: $5\tau$) prima di
	   eseguire l'azione di $Lmp_i$, in modo tale da poter ricevere le wave mancanti, e
	   quindi mantenere l'ordine causale delle azioni;
	\item $Lmp_i < Lmp_n$: vado ad eseguire l'azione solo nel caso in cui tutte le variabili
	   coinvolte non siano già state modificate da una wave ad essa successiva, cioè con
	   $clock > Lmp_i$.
\end{itemize}

\subsection{Algoritmo: Distribuited Spanning Tree}\label{algo:dstp}
L'albero di copertura (o spanning tree) è un protocolo distribuito tra i nodi ideato per limitare il numero di messaggi nella rete. Questo protocollo risulta essere una versione modificate el più noto \textit{STB} (IEEE 802.1aq). Tutto questo protocollo viene eseguito sempre dal sistema di heartbeat, in quanto strettamente correlati.

Questo protocollo si divide in 3 fasi:
\begin{itemize}
    \item \textit{\textbf{discovery}}: in questa fase, il nodo che si sta connettendo esplora la rete, e dice a tutti di essere la radice. A seconda delle condizioni, esplicitate in dettagli nel capitolo successivo, potrà effettivamente esserlo o meno;
    \item \textit{\textbf{listening}}: in questa fase, l'albero risulta stabile. Ogni $\bar{\tau}$ la radice ``eletta'' manda dei pacchetti di keep alive ai figli. Nel momento in cui un la radice cesserà la sua permanenza nella rete, si passerà alla fase successiva;
    \item \textit{\textbf{transiction}}: in questa fase, per almeno uno componente della rete, la radice risulta non più raggiungibile. In questa fase i nodi coinvolti, non possono accettare la vecchia radice. Questa fase avviene quando un nodo perde la sua ``radice'', o quando lo spanning tree perde la radice che lo genera.
\end{itemize}

La scelta della radice avviene in maniera deterministica, sfruttando l'identificatore univoco di cui ogni nodo è dotato. Definiamo come \textit{tree\_state} la tupla definita come $<saved\_root, saved\_len, saved\_nh>$, la quale identifica l'identificativo della radice attualmente salvata, la mia attuale distanza e attraverso quale vicino riesco a raggiungerla, mentre definiamo come $<root, len, nh>$ la tupla proposta dai miei vicini. A questo punto la scelta per un nodo della sua radice avviene come segue:
\begin{itemize}
    \item $saved\_root > root$: la radice proposta è inferiore alla mia e sarà scelta come mia nuova radice;
    \item $saved\_root = root \land saved\_len + 1 < len$: il mio vicino è ha una distanza peggiore della mia, lo avviso che il mio percorso potrebbe essere migliore;
    \item $saved\_root = root \land saved\_len > len + 1 $: la mia distanza è peggiore di quella proposta, mi sposto sul mio vicino, in maniera di esser più vicino alla radice;
    \item $saved\_root = root \land saved\_len = len + 1  \land nh\_saved > nh$: per questioni di determinismo, se la distanza e la radice proposta sono identiche, scelgo come ``porta'' verso la radice il mio vicino con id minore degli altri.
\end{itemize}

A questo punto possiamo scegliere anche a quali dei nostri possiamo inviare i messaggi: poichè ogni nodo è informato se è un nodo scelto o meno, se inoltriamo i messaggi solo ai vicini in cui sono stato scelto o al vicino che io ho scelto, posso raggiungere tutta la rete con un numero minimo di messaggi. A tal fine ogni vicino potrà assumere 3 vari stati:
\begin{itemize}
    \item\textit{root\_port}: vicino scelto per raggiungere la radice;
    \item\textit{active}: vicino che mi ha scelto per raggiungere la radice;
    \item\textit{disabled}: vicino che non dipende da me.
\end{itemize}


\section{Architettura fisica e deployment}
Per quanto riguarda l'architettura fisica è necessario l'utilizzo di microcalcolatori,
	   come dei ``Raspberry'' o degli ``Arduino''. Ogni nodo corrisponderebbe fisicamente
	   ad una di queste schede, avendo quindi la possibilità d'utilizzare più nodi
	   per
	   il medesimo ``apparato''.

Non è strettamente necessario l'ausilio di microcalcolatori: potrei concentrare
	   all'interno di un singolo calcolatore più nodi, a patto che siano gestiti in
	   maniera
	   consona. 

Come descritto in precedenza, questi comunicherebbero con protocollo TCP ed UDP,
	   non interessandoci quindi di tutta la rete sottostante.

Visto l'esempio a cui abbiamo pensato, si ritiene ideale l'utilizzo di connessioni
	   wireless.
\section{Piano di sviluppo}
Le \textbf{funzionalità di base} che verranno implementate sono:
\begin{itemize}
	\item comunicazione tra nodi;
	\item sistema di flooding;
	\item sistema di heartbeat;
	\item gestione dell'aggiunta di un nodo alla rete;
	\item gestione del riavvio di un nodo nella rete;
	\item impostazione iniziale dei nodi (ambiente);
	\item programmazione dei nodi;
	\item sistema basico d'esecuzione delle regole.
\end{itemize}
Sono state inoltre individuate le seguenti \textbf{funzionalità avanzate}:
\begin{itemize}
	\item sistema avanzato d'esecuzione delle regole;
	\item salvataggio dello stato del nodo su files interni al controllore;
	\item riprogrammazione dinamica del nodo;
	\item implementazione di un \emph{calculus} locale.
\end{itemize}

\chapter{Implementazione}
In questo capitolo tratteremo le scelte implementative avvenute nel corso del progetto. ci focalizzaremo man mano nei vari dettagli, cercando di spiegarne le motivazioni delle varianti adottate dai vari algoritmi o protocolli standard.

\section{Software e hardware}
Per l'implementazione non si è seguita una vera e propria scelta hardware, ma si è tenuto conto i vincoli, quali scarsa capacità computazionale e scarsa memoria.

A livello software la scelta è ricaduta su Erlang, in quanto linguaggio fortemente orientato ai threads, funzionale e con spiccata capacità alle connessioni. Altra peculiarità sono le librerie messe a disposizione dallo stesso tramite OTP (Open Telecom Platform). Di queste librerie sfrutteremo fortemente dei ``behavior module'', quali \textit{gen\_server} e \textit{supervisor}, i quali danno a disposizione l'astrazione del meccanismo del client/server e di supervisione dei threads del processo in vita. Essendo fortemente orientato ai threads e funzionale, per poter utilizzare dei timer siamo dovuti ricorrere ad un particolare meccanismo: una funzione messa a disposizione da erlang, chiamata \textit{send\_after}, che ci permette di inviare un messaggio ad un modulo passato come parametro dopo un intervallo di tempo specificabile, in questo modo siamo riusciti ad evitare il blocco dell'esecuzione di un processo.

I moduli sviluppati più interessanti saranno quindi descritti in dettaglio nei paragrafi successivi.

\section{Utilizzo dei ``Supervisors''}
Come già accennato, il meccanismo dei supervisor permette di gestire tutti i threads che verranno creati per i vari processi del nodo. Come si può notare in figura \ref{img:struttura_nodo}, abbiamo due supervisor: uno principale che rappresenta il vero e proprio nodo ed un secondo per mantenere la vitalità di tutti i processi interni legati alla comunicazione (dal modulo ``rules\_worker'' al più semplice ``HB\_out'').

Il primo supervisor, generato dal modulo \textit{``supervisor\_nodo''}, provvede a sopperire alla necessità di mantenere in vita tutti quei dati essenziali al funzionamento del nodo. Al suo interno infatti verranno istanziate le tabelle ``ets'' dove vengono salvate tutte le informazioni relative alle funzionalità del nodo (lo stato dell'albero, il clock, le regole,...), verrà istanziato il thread designato alla comunicazione con l'ambiente, e per finire anche il thread che si occuperà di manipolare in maniera \textit{sicura} i parametri del nodo. Ultimo, ma non per importanza, verrà generato come figlio del supervisor generale del nodo, il supervisor dei ``workers'', che si occuperà di mantenere in vita i thread per l'heartbeat e per chi interpreterà le regole.

Codice d'esempio si trova nell'appendice \ref{code:supervisor}.

\section{Heartbeat (module: HB\_in)}\label{impl:hbin}
Come descritto precedentemente, nel modulo \textit{HB\_in} possiamo trovare tutti i meccanismi legati alla gestione della rete e delle sue funzionalità come tale. Nello specifico, questo si occupa solamente di controllare la ``vitalità'' di un nodo e di creare un albero di copertura della rete stabile, con tutti i suoi protocolli annessi.

\subsection{Heartbeat - consistenza della rete}
La prima funzionalità (appunto, garantire la consistenza della rete), serve a garantire che se un nodo a me vicino si spenga o diventi non più raggiungibile, allora non debba più considerarlo come mio vicino. La consistenza della rete avviene tramite alcune variabili di stato interne al modulo, identificabili dalla tupla:
$$
    <neighb\_clocks, neighb\_state>
$$
Il primo valore della tupla identifica una mappa di tipo $<id, clock>$, e mi serve nel momento in cui avviene un aggiornamento del clock interno dovuto al ricongiungimento di una rete partizionata: per cercar di garantire la consistenza delle wave di regole che si propagheranno nella rete, dovrò cercare di allineare tutti i componenti della rete al medesimo clock.
Il secondo valore della tupla identifica una mappa del tipo $<id, stato>$: per controllare la vitalità di un nodo devo infatti verificarne la sua presenza attraverso il meccanismo di ``echo'' descritto nel paragrafo \ref{heartbeat}. Alla creazione del nodo suppongo che tutti i miei vicini siano ``vivi'', e saranno considerati tali fino a prova contraria (ovvero quando non risponderanno più agli echo). Gli \emph{stati} assumibili dai vicini in questa mappa quindi saranno:
$$
stato(\eta:neightboard)=\begin{cases}
                         alive, & \mbox{se }\eta\mbox{ ha risposto all'ultimo echo} \\
                         maybe\_death, & \mbox{se }\eta\mbox{ non ha risposto all'ultimo echo}\\
                         death, & \mbox{se }\eta\mbox{ non ha risposto agli ultimi due echo}
                   \end{cases}
$$
con $\eta$ vicino di ogni nodo.\\
Si rimanda all'appendice \ref{code:heartbeat} per ulteriori esemplificazioni.

Un vicino si dichiara $maybe\_death$ dopo $\tau = 5s$, e $death$ dopo $2*\tau$.

\subsection{Heartbeat - spanning tree}
Come abbiamo già accennato in precedenza, il protocollo di spanning tree prende spunto dal più famoso \textit{spanning tree protocol} adottato dai bridge. 

Questo protocollo basa il suo funzionamento sull'interscambio di tuple:
\begin{enumerate}
\item $<tree\_state,<root,len,nh>>$: questa tupla indica lo stato dell'albero per il nodo che la propaga. Essa infatti contiene chi è la radice per quel nodo, quanto essa è distante e chi è che manda fuori il pacchetto;
\item $<tree\_ack, id>$: questo pacchetto avvisa il nodo vicino che verrà usato per ``instradare'' pacchetti nella rete;
\item $<tree\_rm\_rp, id>$; avvisa la mia vecchia \textit{root\_port} che non la utilizzo più per instradare pacchetti.
\end{enumerate}
Per ulteriori delucidazioni su come vengono intraprese le scelte si rimanda al paragrafo \ref{algo:dstp}.

La necessità di avvisare i nodi vicini che li usiamo come root port o meno nasce dalla particolare situazione in cui ci troviamo: poiché non abbiamo un vero e proprio ambiente dove un nodo non designato al raggiungimento della radice comunica con tutti i nodi di quella zona, siamo costretti ad avvisare se un nodo è una root\_port o meno. Questo passaggio complica la rete, in quanto crea un ``overhead'' di messaggi normalmente non contemplato dal protocollo originale.

Ulteriormente, poichè tutti i nodi non possono accorgersi in ``tempo reale'' della situazione delle loro ``porte'' (dato che sono tutte connessioni punto-punto), si richiede l'utilizzo di ulteriori clock per la correttezza dell'albero: uno per i timeout della vitalità della radice ed uno per evitare di utilizzare immediatamente una radice che si ipotizzava fosse morta. L'utilizzo di questi clock creano altri messaggi di saturazione della ``rete emulata'', desincronizzano i vari nodi, peggiorandone le performance, ed imponendo necessariamente una potenza di calcolo più grande in quanto non sia una rete fisica.

Nel nostro specifico caso, viene fissato $\bar{\tau} = 2 s$ per il messaggio di vitalità della radice, $2*\bar{\tau}$ come timeout,  $3*\bar{\tau}$ come timeout per accettare di nuovo la vecchia radice.

\subsection{Heartbeat - comunicazioni in uscita}
Per le comunicazioni in uscita, come possiamo notare da alcune linee di codice dell'appendice \ref{code:heartbeat}, interpelliamo il modulo \textit{HB\_out}: questo modulo gestisce le comunicazioni in uscita, compresi gli errori di comunicazione. Parametri richiesti per la comunicazione verso l'esterno sono:
\begin{itemize}
\item \textit{pacchetto}: il messaggio già confezionato da inviare
\item \textit{vicini}: una lista iterabile di vicini a cui mandarlo (per precisione, al loro hearbeart).
\end{itemize}
Questo thread viene direttamente creato dal modulo di \textit{HB\_in}, ed appena esaurisce la lista cessa la sua esistenza.

Si rimanda al file in \texttt{src/HB\_out.erl} per vedere in dettaglio il suo funzionamento.

\section{Comunicazione coi vicini (module: comm\_IN)}

La comunicazione delle regole da eseguire con i vicini avviene tramite l'utilizzo dei moduli \textit{comm\_IN} e \textit{comm\_OUT}.
\begin{description}
\item[\textit{comm\_IN}]: questo modulo si trova perennemente in uno stato di ricezione, in modo da processare nel minor tempo possibile tutti i messaggi ricevuti dai vicini. In particolare  gestisce l'algoritmo di \textit{flooding}: per fare ciò genera al suo avvio una tabella (\textit{ets}) per il salvataggio ed il controllo dei messaggi. Nel momento in cui arriva un messaggio di \textit{flood} questo viene controllato, tramite la tabella, per decidere se sia un nuovo messaggio oppure uno già visto in precedenza: nel secondo caso il messaggio viene ignorato, altrimenti viene processato tramite il modulo apposito (\textit{rules\_worker}, trattato al paragrafo \ref{impl:rules_worker}) e poi inviato ai vicini, escludendo chi l'aveva inviato. %TODO: ma non invia e poi processa?
\item[\textit{comm\_OUT}]: questo modulo è strutturato quasi identicamente a quello di \textit{HB\_OUT}, viene infatti utilizzato da \textit{comm\_IN} per inviare messaggi ai vicini gestendo possibili errori di comunicazione e alla conclusione cessa di esistere.
\end{description}

\section{Memoria dei parametri (module: state\_server)}
Ogni nodo, come esplicitato nei requisiti funzionali (paragrado \ref{sec:funcReq}), necessita d'essere programmabile e d'avere un insieme di variabili di stato proprie. Oltre a questo, si ha la necessità di conoscere e di poter interpretare delle regole definite all'avvio del nodo. Oltretutto, poiché si ha a che fare con un ambiente virtualizzato, necessitiamo di sapere quali sono i vicini con cui collabora.

Tutte queste informazioni, come già esplicitato nel capitolo precedente e nei paragrafi precedenti, sono salvate all'interno di uno ``state server'', il quale opera su delle tabelle persistenti (a meno di un riavvio totale del nodo), create e fornite dal supervisor del nodo, al fine di non aver problematiche in caso di fallimenti.

Lo state server è incentrato in un'ottica client/server: per questo motivo il suo behavior module è \textit{gen\_server}.

Lo state server si occupa quindi di accedere in maniera sicura e non concorrenziale alle variabili a suo carico, al fine di non generare situazioni di deadlock o starvation.

Lo stato dello \textit{state\_server} sarà quindi composto dalla tupla
$$
    <vars\_table, rules\_table, neighb\_table, node\_params\_table>
$$
dove ogni campo equivale a:
\begin{itemize}
    \item \textit{vars\_table}: tabella delle variabili;
    \item \textit{rules\_table}: tabella delle regole;
    \item \textit{nb\_table}: tabella dello stato dei vicini;
    \item \textit{node\_params\_table}: tabella dei parametri interni al nodo.
\end{itemize}

La prima tabella contiene una tupla per ogni variabile: il nome ed il valore iniziale dipende dal tipo del nodo. Di ogni elemento sarà quindi salvato il nome della variabile, il suo valore attuale ed infine un ulteriore parametro che indica il valore del clock associato all'ultima azione che ha modificato tale variabile. Quest'ultimo campo permette di mantenere un ordine causale degli eventi: quando un'azione deve essere eseguita viene controllato che le variabili utilizzate, sia nelle condizioni/guardie, che negli assegnamenti, non abbiano un valore di clock di ultima modifica maggiore o uguale a quello dell'azione in questione. Questa scelta permette di evitare che un evento ``vecchio'', arrivato in ritardo in un nodo, non sovrascriva cambiamenti indotti da eventi più recenti. 

Nella seconda tabella sono presenti tutte le regole legate al tipo del nodo in questione. L'utilizzo di queste tuple verrà affrontato in miglior dettaglio nel paragrafo \ref{impl:rules_worker}.
La struttura delle regole è presentata in un file apposito (\textit{rules\_expl} \ref{code:rulesstruct}).

Gli elementi di queste due prime tabelle vengono inseriti alla creazione del nodo: all'avvio di un nodo del tipo \textit{type} viene cercato e caricato il file \textit{<type>\_rules.txt} il quale contiene la lista delle variabili ed una lista di regole di quel specifico tipo di nodo. Se il file non viene trovato, viene caricato quello per un nodo di tipo \textit{default}.

I valori associati alla terza componente sono strettamente correlati a quanto affrontato nel paragrafo \ref{impl:hbin}: al suo interno troveremo delle tuple con i valori legati allo spanning tree tali da poter sapere se inoltrare o meno un messaggio a quel nodo. L'inoltro di un messaggio verso un nodo avviene solo nel caso in cui il vicino sia in stato $active$ o $root\_port$.

I valori associati al quarto membro della tupla sono invece legati ad informazioni chiave per identificare il nodo di appartenenza. Al suo interno possiamo trovare alcune voci, quali ad esempio: il suo identificativo univoco, che tipo di nodo è per la rete, quante \textit{``rules wave''} ha visto, il suo clock interno e chi è la sua radice. Queste informazioni sono identificative ed univoche per un nodo, e sono il suo stato interno.

Poiché lo state server è l'unico a poter manipolare le variabili del nodo, al suo interno avrà un piccolo ``interprete'' per manipolare e controllare le variabili. Questo avviene in maniera ricorsiva mediante l'utilizzo di una funzione ricorsiva chiamata ``check\_condition'' (si rimanda all'appendice \ref{code:stateserver} per ulteriori delucidazioni).

Oltre a tutto ciò questo modulo mantiene all'interno del suo stato un flag chiamato \textit{is\_tree\_stable}. Questo parametro booleano viene utlizzato per decidere, nel momento dell'invio di un messaggio, se utilizzare solamente i vicini attivi secondo lo \textit{spanning~tree} (\ref{algo:dstp}), nel caso sia \texttt{true}, oppure usare tutti quelli conosciuti (tramite \textit{flooding} \ref{alg:flooding}). Viene utilizzato questo flag perché nel momento in cui la struttura dell'albero sta eseguendo un aggiornamento o una modifica, gli eventi globali potrebbero andare persi. Ogni qualvolta il valore di \textit{tree\_state} viene modificato il parametro in questione viene imposto a \texttt{false} e contemporaneamente viene fatto partire un timer con l'attuale valore di \textit{tree\_state}. Allo scadere del timer, viene controllato che il valore ad esso collegato sia uguale a quello attualmente salvato: in caso affermativo il flag \textit{is\_tree\_stable} viene posto a \texttt{true}.


\section{Esecutore dei comandi (module: rules\_worker)}\label{impl:rules_worker}

Questo modulo, come accennato nei paragrafi precedenti, si occupa dell'esecuzione delle azioni ricevute dai nodi vicini (tramite il modulo \textit{communication\_in}) e di gestire la logica di attivazione delle regole che possono attivarsi.

Il modulo fornisce una funzione apposita (\textit{exec\_action}) la quale permettere ad un qualsiasi altro modulo del nodo (in questo caso solamente \textit{communication\_in} e \textit{communication\_ambiente}) di inviare ad esso un'azione da eseguire. Una volta ricevuta un'azione, viene eseguito il controllo del valore del clock legato ad essa: se il clock ricevuto fosse maggiore del valore previsto dal nodo (cioè il valore di clock salvato $+ 1$), l'azione viene inserita in una lista di attesa (\textit{on\_timer\_hold}, presente nello stato interno del modulo) nella quale rimarrà finché non vengono eseguite le azioni mancanti, le quali porterebbero il valore atteso dal nodo a quello in questione, oppure finché non scade l'apposito timer istanziato nel momento in cui l'azione veniva aggiunta alla lista.\\ % TODO: durata timer
Nel momento in cui un'azione ricevuta possieda un valore di clock minore o uguale al valore atteso dal nodo, oppure è stata appena estratta dalla lista \textit{on\_timer\_hold}, viene inserita in una coda di esecuzione (\textit{action\_queue}) aggiornando il valore di clock del nodo in accordo. Questa coda verrà svuotata da una routine apposita, mentre il nodo potrà continuare ad eseguire i calcoli necessari, senza bloccare la possibilità di ricevere ulteriori azioni dai nodi vicini. 

Per processare le varie azioni inserite nella coda viene utilizzato un segnale apposito interno al modulo (\textit{handle\_next\_action}): nel momento in cui si sta per inserire una nuova azione nella coda si controlla se questa sia vuota, e, in caso affermativo, il modulo invia a se stesso il messaggio in questione. Questo meccanismo permette d'avere sempre e solo un segnale di questo tipo. Nel momento in cui si finisce di processare un'azione estratta dalla testa della coda, si procede, eventualmente, ad eseguire la prossima azione ``rinviandosi'' il messaggio di prima, fino all'esaurimento della stessa.


\subsection{Esecuzione di un'azione}

Finché la coda \textit{action\_queue} non è vuota, vado ad estrarre la prossima azione da processare dalla sua testa. L'azione estratta verrà inoltrata allo state server tramite funzione apposita: questo, al termine della stessa, mi restituirà un'elenco delle variabili modificate. Questa funzione, prima di procedere con l'esecuzione dell'azione richiesta, controlla se le variabili presenti nella guardia e nelle istruzioni dell'azione siano eseguibili. Gli step per eseguire un'azione sono:
\begin{enumerate}
    \item si controlla inizialmente che i nomi delle variabili siano presenti come variabili locali;
    \item si verifica che il valore di ultima modifica di ogni variabile non sia maggiore o uguale al valore di clock legato all'azione in questione;
    \item si verifica la soddisfacibilità del valore di guardia dell'azione.
\end{enumerate}
In caso di valutazione positiva di tutti i passi, verranno eseguite le varie istruzioni richieste dall'azione. Una volta terminata l'azione lo \textit{state\_server} cerca tutte le regole che vengono attivate dalle modifiche appena eseguite (ovvero, se tutti i valori di trigger sono soddisfatti) e le restituisce sotto forma di lista.

Le nuove regole attivate devono essere processate prima di eseguire una nuova azione: per questo motivo verranno inserite in una coda prioritaria (\textit{priority\_queue}). Questa coda viene trattata in egual maniera rispetto all'\textit{action\_queue}, ma ha la precedenza rispetto a questa.

Al termine di queste operazioni si verifica se nella lista \textit{on\_timer\_hold} ci siano delle regole che possano essere eseguite: se è possibile vengono estratte le regole interessate e verranno inserite in coda nell'\textit{action\_queue}.

\subsection{Processamento delle regole}
I passi eseguiti per il processamento delle regole sono simili a quanto detto nel paragrafo precedente: riassumeremo velocemente l'iter delle azioni compiute.
Viene estratta una regola presente in testa alla coda \textit{priority\_queue}: si procede quindi a verificare la condizione della stessa tramite una funzione apposita dello \textit{state\_server}. Come prima, si controlla se le variabili presenti esistano realmente e se non siano già state modificate da un clock di valore maggiore, infine si esegue il controllo della condizione, restituendo se essa è soddisfatta o meno.\\
In questo caso, diversamente dalle azioni esterne (cioè ricevuto da altri nodi tramite flood), la regola può utilizzare variabili modificate al medesimo valore di clock: in caso in cui più regole vadano ad utilizzare la medesima variabile allo stesso clock (per modifiche o condizioni) è una situazione contemplata.

la regola verrà quindi processata in base al suo tipo:
\begin{description}
\item[Locale] l'azione associata viene trattata come fosse una normale azione da eseguire: viene chiamata l'apposita funzione dello \textit{state\_server}, il quale restituisce la lista di regole attivate e che a loro volta verranno inserite nella \textit{priority\_queue}. Queste nuove regole devono essere inserite in testa alla coda, in questo modo elaborare prima gli effetti causati dalla regola appena processata.
\item[Globale] in questo caso l'azione associata non deve essere eseguita internamente dal nodo in questione, ma deve essere propagata ai vicini creando un nuovo \textit{flooding} utilizzando il valore di clock adeguato.
\item[Transazione] la regola estratta genera una transazione. Si procede inviando alla rete il messaggio di proposta di transazione. Lo \textit{rules\_worker} del nodo ricevente il messaggio di proposta deve controllare se è anch'esso può partecipare alla transazione: in caso affermativo viene bloccata l'esecuzione delle regole nelle code per dedicarsi solamente a questa, mentre, se decreta di non essere un partecipante, può procedere con la normale esecuzione, garantendo ai nodi terzi lo svolgimento della transazione.\\
Lo stato del modulo viene controllato tramite l'ausilio di una variabile di stato, la quale indica in quale momento della transazione mi trovo:
\begin{itemize}
\item $\{none\}$: non mi trovo in una transazione.
\item $\{started\_transaction, Transact\_clock, Partecipants, Action\}$: ho iniziato una nuova transazione, quindi aspetto le risposte dei nodi che vogliono partecipare aggiungendoli alla lista $Partecipants$ finché non scade il timer associato.
\item $\{waiting\_commit, Id\_gen, Transact\_clock, Action\}$: ho risposto ad una richiesta di transazione dicendo di voler partecipare, aspetto il messaggio di commit o la fine del timer apposito.
\end{itemize}

Nel caso in cui la transazione vada a buon fine, l'azione viene eseguita utilizzando la medesima sequenza di comandi usata nei casi precedenti. Una spiegazione grafica sulla ``vita'' di una transazione la si può vedere in figura \ref{img:transazioni}.

\end{description}

\section{Ambiente e comunicazione con i nodi}
Il modulo \textit{ambiente} risulta essere quel processo dedito a virtualizzare il mondo fisico dove normalmente i nodi coopererebbero. Questo modulo è quindi essenziale per il funzionamento e la coordinazione dei nodi e delle azioni nel ``mondo'' messo a disposizione da \textit{Erlang}.

Lo stato dell'ambiente risulta esser caratterizzato da:
\begin{itemize}
    \item un grafo della rete;
    \item la mappa degli id per comunicare con ogni nodo, specificamente:
    \begin{itemize}
        \item la mappa per identificare il pid del thread;
        \item la mappa per identificare il processo per ricevere le comunicazioni dall'ambiente per ogni nodo;
        \item la mappa del supervisor di ogni nodo.
    \end{itemize}
\end{itemize}
Queste variabili servono da supporto per le funzionalità da lui offerte, quali:
\begin{enumerate}
    \item simulare la rottura di un link tra due nodi;
    \item aggiungere un nodo;
    \item inviare un'azione specifica ad un nodo;
    \item terminare l'esistenza di un nodo;
    \item terminare la ``virtualizzazione'' del mondo.
\end{enumerate}
Compito essenziale dell'ambiente risulta essere quello di generare la rete e rendere consistente il grafo rappresentativo della stessa: proprio grazie a questo potremo simulare con semplicità le variazioni fisiche del grafo dovuti ad azioni nella rete stessa.\\
Esempio della descrizione del grafo sarà:
\begin{tcolorbox}[colback=yellow!5!white,colframe=lime!75!black,title=Grafo totalmente connesso]
\begin{center}
\begin{tabular}{ll} 
\texttt{[bad, gen].} & \texttt{\%}$\displaystyle \leftarrow$ \texttt{tipi dei nodi possibili nel grafo} \\ 

\texttt{[} &  \\ 

\texttt{~~{a, gen, []},} &  \texttt{\%}$\displaystyle \leftarrow$ \texttt{id, tipo, vicini}\\ 

\texttt{~~{b, gen, [a]},} &  \\ 

\texttt{~~{c, gen, [a, b]},} &  \\ 

\texttt{~~{d, gen, [a, b, c]},} &  \\ 

\texttt{].} &  \\ 
\end{tabular} 
\end{center}
\end{tcolorbox}

Tutte queste funzionalità messe a disposizione da questo modulo saranno sfruttate a pieno per il capitolo successivo, ovvero la fase di test e la fase di validazione del progetto.\\
~\\

Altro paragrafo si apre per il modulo ``\textit{comm\_ambiente}''. Questo modulo si occupa di domandare o ricevere le direttive dal processo dell'ambiente. Le funzioni offerte sono descritte di seguito.
\begin{description}
    \item \textbf{Aggiunta di un nodo:}\\
        ogni nodo, quando deve aggiungere un nuovo nodo, deve ricevere in ingresso i ``puntatori'' ai processi di \textit{hearbeat} e di \textit{comm\_in} del nuovo nodo vicino, al fine di poter attuare tutti i servizi previsti da progetto.
    \item \textbf{Ignorare un vicino:}\\
        ogni nodo, quando apprenderà dall'ambiente che un link si è rotto, smetterà di inoltrare tutti i messaggi verso di lui. Tutti i meccanismi precedentemente descritti sopperiranno alla mancanza di comunicazione: il caso peggiore risulta quindi essere quando la rete si partizione, ovvero quando un nodo risulta isolato nella rete (quindi, non ha vicini).
    \item \textbf{Esecuzione di un'azione:}\\
        al fine di simulare la variazione di una variabile dipendente dall'ambiente (es.: il valore di una termocoppia, l'umidità dell'ambiente,...), il modulo deve poter accettare delle direttive dall'ambiente (e quindi delle azioni) da eseguire per modificare lo stato delle variabili interne, anche eseguendo delle regole locali, globali o delle transazioni.
    \item \textbf{Ricerca dei vicini:}\
            altra funzionalità essenziale offerta da questo modulo risulta essere, in fase di avvio del nodo, la gestione della ricezione della lista dei vicini da parte dell'ambiente.\\
            Come precedentemente accennato, l'ambiente provvedere a memorizzare il grafo della rete partendo da un file descrittivo dell'ambiente stesso: essendo l'ambiente stesso colui che genera ed avvia i nodi nella rete, avrà anche il compito di informare ogni nodo dei suoi vicini.  
        
\end{description}

Alcuni passaggi interessanti sono allegati in appendice \ref{code:ambiente} e \ref{code:commambiente}.


\chapter{Validazione}

Come presentato nell'analisi inizale (\ref{Trasparenze}) le varie trasparenze sono state implementate dal sistema:
\begin{description} 
\item[Trasparenza ai fallimenti:]~\\ nel momento in cui un nodo cessa di funzionare, od una connessione fra due nodi viene a mancare, il sistema reagisce adeguatamente. Il fallimento viene rilevato nel momento in cui la risposta ai messaggi di echo viene a mancare; una volta individuato il malfunzionamento, il nodo aggiorna la propria tabella dei vicini e successivamente il protocollo di \textit{spanning~tree} entra in azione per l'aggiornamento della rete, se necessario.
\item[Trasparenza alla scalabilità:]~\\ la rete può espandersi in dimensione senza che il funzionamento dei nodi vari. Ogni nodo conosce solamente i suoi vicini, questo permette di aggiungere un nuovo nodo alla rete semplicemente comunicando con i rispettivi vicini, i quali rispondereanno in accordo ai vari protocolli usati.
\item[Trasparenza alla mobilità:]~\\ un nodo può spostarsi all'interno della rete senza che il funzionameto suo e degli altri nodi vada a modificarsi. Semplicemente quando un nodo si sposta, elimina dalla lista dei suoi vicini i nodi con cui non può più comunicare ed inserisce quelli nuovi, inizializzando una nuova connessione tramite i protocolli presentati.
\end{description}

\section{Verifica dei requisiti funzionali}

Di seguito andremo a verificare se tutti i requisiti funzionali presentati precedentemente (paragrafo \ref{sec:funcReq}) sono stati soddisfatti o meno.

\begin{description}
\item[Categorizzazione di un nodo:]~\\ ogni nodo al momento dell'istanziazione deve ricevere in input il tipo di appartenenza;
\item[Modifica delle regole di un nodo:]~\\ ogni tipo di nodo ha le sue regole, codificabili attraverso la programmazione dello stesso: ogni qualvolta un nodo verrà istanziato andrà a caricare da un file apposito la lista di variabili e le regole specifiche per il suo tipo;
\item[Modifica dello stato di un nodo:]~\\ ogni evento avrà degli \textit{effetti locali}, degli \textit{effetti globali} o degli \textit{effetti transazionali}:
	\begin{itemize}
	\item \textit{\textbf{effetti locali}}: la regola modifica lo stato interno tramite l'utilizzo delle funzioni fornite dallo \textit{state\_server};
	\item \textit{\textbf{effetti globali}}: la regola genera un evento che sarà propagato a tutti i nodi della rete utilizzando i meccanismi di comunicazione internodo (\textit{flooding} o tramite \textit{spanning~tree});
	\item \textit{\textbf{effetti transizionali}}: regola simile ad una globale, ma con la differenza che l'esecuzione avverrà in tutti i nodi coinvolti ``contemporaneamente'', posticipando qualunque altra azione ricevuta fra l'accettazione della transazione e la sua eventuale esecuzione;
	\end{itemize}
\item[Aggiunta dinamica di un nodo:]~\\ un nodo può essere aggiunto alla rete in qualsiasi momento senza perturbarne la dinamicità, coinvolgendo solamente i vicini a cui si collega. All'atto dell'aggiunta verranno scambiate le informazioni necessarie per la partecipazione alla rete seguendo le istruzioni fornite dai protocolli.
\item[Esecuzione di un'azione ricevuta dai vicini:]~\\ nel momento in cui un nodo riceve un messaggio dai propri vicini, esso va a verificare la soddisfacibilità della guardia (se presente) e nel caso di una valutazione positiva verrà eseguita l'azione associata, andando quindi a modificare il proprio stato.
\item[Attivazione di una regola:]~\\ ogni qualvolta avviene un cambiamento nello stato di un nodo, viene eseguito un controllo delle regole, verificando se gli eventi generati hanno attivato una o più regole del nodo; nel caso in cui una regola venga attivata, in base al tipo (locale, globale o transazione), viene portata a termine l'azione corrispondente, dando precedenza a quelle locali.
\end{description}

Procediamo quindi alla verifica puntuale dei requisiti appena descritti.

\section{Test delle funzionalità}

La rete testata è formata come segue:
\begin{figure}[H]
\makebox[\linewidth][c]{\includegraphics[scale=0.80]{rete.pdf}}
\caption{Struttura della rete.} 
\end{figure}
I nodi in verde son o i nodi che possono esser aggiunti durante i vari test, l'arco in arancione sarà l'arco che verrà ``disabilitato'' durante il test, i nodi in rosso sono quelli che durante i test possono esser rimossi. 

I test sono stati eseguiti come segue (istruzioni per l'uso nell'appendice \ref{istruzioni}):

\subsection{Test aggiunta di un nodo: \texttt{test\_add\_node.erl}}

Questo test va a verificare che l'aggiunta di un nodo avvenga in maniera dinamica e conforme al requisito funzionale descritto precedentemente.
Si divide in due casi:
\begin{itemize}
\item aggiunta di un nodo che non diventerà la nuova radice (funzione \texttt{add\_foglia})
\item aggiunta di un nodo con identificativo minore e quindi sarà eletta nuova radice della rete (funzione \texttt{add\_radice})
\end{itemize}

Listato della funzione \texttt{add\_foglia}:
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{add\_foglia} (1)]
\begin{center}
\begin{verbatim}
1> test_add_node:add_foglia(). 
Ricevuta lista di vicini: [{b,b_heartbeat_in}].
Ricevuta lista di vicini: [{b,b_heartbeat_in},
                           {c,c_heartbeat_in}].
Ricevuta lista di vicini: [{b,b_heartbeat_in},
                           {c,c_heartbeat_in},
                           {d,d_heartbeat_in}].
\end{verbatim}
\end{center}
\end{tcolorbox}
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{add\_foglia} (2)]
\begin{center}
\begin{verbatim}
Ricevuta lista di vicini: [{c,c_heartbeat_in},
                           {e,e_heartbeat_in}].
b: Sono entrato in start_tree.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
d: Sono entrato in start_tree.
c: Sono entrato in start_tree.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
e: Sono entrato in start_tree.
Ricevuta risposta in aggiunta alla rete dai vicini.
b: Ricevuto tree_state: {d,0,d}.
c: Ricevuto tree_state: {d,0,d}.
d: Ricevuto tree_state: {c,0,c}.
f: Ricevuto tree_state: {c,0,c}.
e: Ricevuto tree_state: {d,0,d}.
b: Ricevuto tree_state: {c,0,c}.
c: Ricevuto tree_state: {e,0,e}.
d: Ricevuto tree_state: {e,0,e}.
f: Sono entrato in start_tree.
e: Ricevuto tree_state: {c,0,c}.
[...]
c : Albero stabilizzato.
d : Albero stabilizzato.
f : Albero stabilizzato.
e : Albero stabilizzato.
Ricevuta lista di vicini: [{e,e_heartbeat_in},
                           {d,d_heartbeat_in}].
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
g: Sono entrato in start_tree.
e: Ricevuto tree_state: {g,0,g}.
d: Ricevuto tree_state: {g,0,g}.
g: Ricevuto tree_state: {b,1,e}.
g: Ricevuto tree_state: {b,1,d}.
d: Ricevuto tree_state: {b,2,g}.
e: Ricevuto tree_state: {b,2,g}.
g : Albero stabilizzato.
f: Vicini: [{e,e_heartbeat_in,disable},
            {c,c_heartbeat_in,route_port}].
ok
2> 
\end{verbatim}
\end{center}
\end{tcolorbox}

Listato della funzione \texttt{add\_radice}:
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{add\_radice} (1)]
\begin{center}
\begin{verbatim}
1> test_add_node:add_radice().
Ricevuta lista di vicini: [{b,b_heartbeat_in}].
Ricevuta lista di vicini: [{b,b_heartbeat_in},
                           {c,c_heartbeat_in}].
Ricevuta lista di vicini: [{b,b_heartbeat_in},
                           {c,c_heartbeat_in},
                           {d,d_heartbeat_in}].
Ricevuta lista di vicini: [{c,c_heartbeat_in},
                           {e,e_heartbeat_in}].
b: Sono entrato in start_tree.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
c: Sono entrato in start_tree.
d: Sono entrato in start_tree.
Ricevuta risposta in aggiunta alla rete dai vicini.
Ricevuta risposta in aggiunta alla rete dai vicini.
e: Sono entrato in start_tree.
b: Ricevuto tree_state: {d,0,d}.
Ricevuta risposta in aggiunta alla rete dai vicini.
c: Ricevuto tree_state: {d,0,d}.
d: Ricevuto tree_state: {c,0,c}.
e: Ricevuto tree_state: {d,0,d}.
c: Ricevuto tree_state: {e,0,e}.
d: Ricevuto tree_state: {e,0,e}.
f: Ricevuto tree_state: {c,0,c}.
b: Ricevuto tree_state: {c,0,c}.
d: Ricevuto tree_state: {c,0,c}.
e: Ricevuto tree_state: {c,0,c}.
f: Sono entrato in start_tree.
c: Ricevuto tree_state: {d,1,e}.
[...]
d : Albero stabilizzato.
c : Albero stabilizzato.
e : Albero stabilizzato.
f : Albero stabilizzato.
Ricevuta lista di vicini: [{e,e_heartbeat_in}].
Ricevuta risposta in aggiunta alla rete dai vicini.
\end{verbatim}
\end{center}
\end{tcolorbox}
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{add\_radice} (2)]
\begin{center}
\begin{verbatim}
a: Sono entrato in start_tree.
e: Ricevuto tree_state: {a,0,a}.
c: Ricevuto tree_state: {a,1,e}.
[...]
d: Ricevuto tree_state: {a,2,b}.
e : Albero stabilizzato.
d : Albero stabilizzato.
f : Albero stabilizzato.
c : Albero stabilizzato.
b : Albero stabilizzato.
a: Vicini: [{e,e_heartbeat_in,active}].
e: Vicini: [{f,f_heartbeat_in,active},
            {d,d_heartbeat_in,active},
            {c,c_heartbeat_in,active},
            {b,b_heartbeat_in,active},
            {a,a_heartbeat_in,route_port}].
ok
2>
\end{verbatim}
\end{center}
\end{tcolorbox}

\subsection{Test aggiunta di un nodo: \texttt{test\_event.erl}}
Questo test va a verificare la veridicità dei requisiti di:
\begin{itemize}
    \item attivazione di una regola;
    \item modifica dello stato di un nodo;
    \item esecuzione di un'azione ricevuta dai vicini.
\end{itemize}
Le funzioni messe a disposizione sono:
\begin{enumerate}
    \item \texttt{transaction}: va ad eseguire una transazione nella rete;
    \item \texttt{regole\_a\_cascata}: va ad eseguire una catena di regole nella rete.
\end{enumerate}

Listato della funzione \texttt{transaction}:
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{transaction} (1)]
\begin{center}
\begin{verbatim}
[...]
d Rules worker - Ricevuta azione: {{},[{x1,2},{x2,3}]}.
d State_server - Ricevuta call con azione: 
    {{}, [{x1,2},{x2,3}]}.
d rules_worker - Letta regola di transazione: 
    {{tpe,gen}, [{x8,22}]} (true).
b : Received transaction request: {{tpe,gen},[{x8,22}]}.
\end{verbatim}
\end{center}
\end{tcolorbox}
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{transaction} (2)]
\begin{center}
\begin{verbatim}
b Rules worker - Ricevuta azione: {{tpe,gen},[{x8,22}]}.
e : Received transaction request: {{tpe,gen},[{x8,22}]}.
c : Received transaction request: {{tpe,gen},[{x8,22}]}.
c Rules worker - Ricevuta azione: {{tpe,gen},[{x8,22}]}.
e Rules worker - Ricevuta azione: {{tpe,gen},[{x8,22}]}.
f : Received transaction request: {{tpe,gen},[{x8,22}]}.
f Rules worker - Ricevuta azione: {{tpe,gen},[{x8,22}]}.
e rules_worker - Ricevuta transaction_rqs.
c rules_worker - Ricevuta transaction_rqs.
b rules_worker - Ricevuta transaction_rqs.
f rules_worker - Ricevuta transaction_rqs.
c : Received transaction req ack: {4,d} of f.
b : Received transaction req ack: {4,d} of e.
f : Received transaction req ack: {4,d} of c.
e : Received transaction req ack: {4,d} of b.
d : Received transaction req ack: {4,d} of b.
b : Received transaction req ack: {4,d} of c.
c : Received transaction req ack: {4,d} of b.
d Rules worker - Ricevuta transact_ack: {4,b}.
d : Received transaction req ack: {4,d} of e.
d Rules worker - Ricevuta transact_ack: {4,e}.
d : Received transaction req ack: {4,d} of c.
c : Received transaction req ack: {4,d} of e.
b : Received transaction req ack: {4,d} of f.
e : Received transaction req ack: {4,d} of c.
f : Received transaction req ack: {4,d} of b.
d Rules worker - Ricevuta transact_ack: {4,c}.
d : Received transaction req ack: {4,d} of f.
e : Received transaction req ack: {4,d} of f.
f : Received transaction req ack: {4,d} of e.
d Rules worker - Ricevuta transact_ack: {4,f}.
d RW - timer si transaction started finito.
d State_server - Ricevuta call con azione:
    {{tpe,gen}, [{x8,22}]}.
b : Received transaction start: {4,d,[f,c,e,b,d]}.
b Rules worker - Ricevuta transact_commit: {d,4}.
b State_server - Ricevuta call con azione: 
    {{tpe,gen}, [{x8,22}]}.
c : Received transaction start: {4,d,[f,c,e,b,d]}.
e : Received transaction start: {4,d,[f,c,e,b,d]}.
e Rules worker - Ricevuta transact_commit: {d,4}.
c Rules worker - Ricevuta transact_commit: {d,4}.
f : Received transaction start: {4,d,[f,c,e,b,d]}.
e State_server - Ricevuta call con azione: 
    {{tpe,gen}, [{x8,22}]}.
c State_server - Ricevuta call con azione: 
    {{tpe,gen}, [{x8,22}]}.
f Rules worker - Ricevuta transact_commit: {d,4}.
f State_server - Ricevuta call con azione: 
    {{tpe,gen}, [{x8,22}]}.
[...]
2>
\end{verbatim}
\end{center}
\end{tcolorbox}

Listato della funzione \texttt{regole\_a\_cascata}:
\begin{tcolorbox}[colback=yellow!5!white,colframe=cyan!75!black,title=funzione \texttt{regole\_a\_cascata} (1)]
\begin{center}
\begin{verbatim}
[...]
d Rules worker - Ricevuta azione: {{},[{x1,9},{x10,3}]}.
d State_server - Ricevuta call con azione: 
    {{},[{x1,9},{x10,3}]}.
d rules_worker - Letta regola locale: [{x4,7},{x3,5}].
d State_server - Ricevuta call con azione 
    (da una regola locale): [{x4,7}, {x3,5}].
d rules_worker - Letta regola globale:
    {{tpe,gen},[{x9,66},{x7,12}]}.
b : Received: {{tpe,gen},[{x9,66},{x7,12}]}.
b Rules worker - Ricevuta azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
e : Received: {{tpe,gen},[{x9,66},{x7,12}]}.
c : Received: {{tpe,gen},[{x9,66},{x7,12}]}.
e Rules worker - Ricevuta azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
c Rules worker - Ricevuta azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
f : Received: {{tpe,gen},[{x9,66},{x7,12}]}.
f Rules worker - Ricevuta azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
b State_server - Ricevuta call con azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
e State_server - Ricevuta call con azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
c State_server - Ricevuta call con azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
f State_server - Ricevuta call con azione: 
    {{tpe,gen},[{x9,66},{x7,12}]}.
b: Vars table: [{x9,66,4},
                {x8,0,-1},
                {x7,12,4},
                {x6,0,-1},
                {x5,0,-1},
                {x4,0,-1},
                {x3,0,-1},
                {x2,0,-1},
                {x1,0,-1},
                {x10,0,-1}].
[...]
2>
\end{verbatim}
\end{center}
\end{tcolorbox}

\subsection{Test del deperimento di un link: \texttt{test\_ignore.erl}}
In questo test si verifica la robustezza del sistema a dei possibili guasti tra le comunicazioni tra i nodi. Viene simulata la caduta di un collegamento fra due nodi della rete: per fare ciò vengono utilizzate delle funzioni apposite che avvisano il nodo di ignorare i messaggi di un determinato vicino.\\
La funzione per testare la funzionalità è:
\begin{itemize}
    \item \texttt{remove\_connection}: la funzione impone ad un nodo di ignorare un vicino.
\end{itemize}


\subsection{Test della scomparsa di un nodo: \texttt{test\_kill\_node.erl}}
in questo test si verifica la resistenza del sistema alla morte ``accidentale'' dei suoi nodi. Le funzioni a disposizione per testare il sistema sono:
\begin{enumerate}
    \item \texttt{kill\_foglia}: viene ucciso un nodo foglia della rete;
    \item \texttt{kill\_root}: viene ucciso un nodo foglia della rete;
    \item \texttt{kill\_node}: viene ucciso un nodo normale della rete (cioè ne foglia ne radice).
\end{enumerate}


\chapter{Conclusioni}

Per quanto riguarda le funzionalità base del sistema, risultano tutte totalmente implementate e consistenti rispetto a quanto proposto in fase di analisi. I requisiti funzionali e non funzionali risultano rispettati nella loro interezza, come visto nel capitolo precedente.

Per quanto riguarda invece le funzionalità avanzate, c'è stata la predisposizione del codice per una facile implementazione delle stesse, però non è stato possibile implementarle:
\begin{itemize}
\item in merito al sistema avanzato d'esecuzione delle regole è stato predisposto l'iterprete da estendere con le istruzioni annidabili (quali and, or, not, ecc.);
\item il salvataggio dello stato del nodo su file può essere facilmente implementato grazie l'ausilio delle tabelle di ets date a disposizione dal linguaggio, che quindi andrebbero sostituite cone delle dets, sempre fornite da Erlang;
\item per quanto riguarda la riprogrammazione dinamica di un nodo non è stata fatta alcuna predisposizione: risulta essere comunque facilmente implementabile tramite l'aggiunta di apposite funzioni nel modulo \textit{comm\_ambiente} che andrebbero ad appoggiarsi ad altre inseribili nel modulo \textit{state\_server};
\item invece per quanto concerne un possibile \textit{calculus}, data la verifica mediante test risulta possibile la sua teorizzazione. Ovviamente richiede ulteriori studi ed approfondimenti.
\end{itemize}


\appendix
\titleformat{\chapter}[display]
  {\normalfont\large\bfseries}% <- font for label "Appendix A", default \huge
  {\chaptertitlename\ \thechapter}
  {10pt}
  {\large}% <- font for title, default \Huge
\titlespacing{\chapter}{0pt}{*4}{*1}

\chapter{Istruzioni d'utilizzo}\label{istruzioni}

Per la compilazione ed esecuzione del codice bisogna seguire i seguenti passi:
\begin{enumerate}
\item Trovandosi nella cartella del progetto aprire una console ed eseguire il comando: \texttt{erl -make}. Questo permette di compilare tutti i file, andando ad inserire tutti i file binari all'interno della cartella ebin.
\item A questo punto per testare il progetto bisgona inanzitutto aprire la console di erlang. Per fare ciò, da una console sempre nella cartella del progetto, basta eseguire un'istruzione in base al sistema operativo utilizzato:
\begin{itemize}
\item \textbf{Windows:} \texttt{werl -pa ebin}
\item \textbf{Unix based systems:} \texttt{erl -pa ebin} 
\end{itemize}
\item Ora nella console di erlang è sufficiente chiamare le funzioni che si vogliono testare.
\end{enumerate}

\chapter{Supervisors}\label{code:supervisor}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{erlang}
init({Id, Tipo}) ->
  State_tables = create_table(Id, Tipo),
  Server_name = list_to_atom(atom_to_list(Id) ++ "_server"),
  Rules_worker_name = list_to_atom(atom_to_list(Id) ++ "_rules_worker"),
  Comm_ambiente_name = list_to_atom(atom_to_list(Id) ++ "_comm_ambiente"),
  HB_name = list_to_atom(atom_to_list(Id) ++ "_heartbeat_in"),
  MaxRestart = 1,
  MaxRestartPeriod = 5,
  SupFlags = #{strategy => one_for_one, 
               intensity => MaxRestart, period => MaxRestartPeriod},
  ChildSpecs = [
    #{id => state_server,
      start => {state_server, start_link, [Server_name, Id, State_tables]},
      restart => permanent,
      shutdown => infinity,
      type => worker,
      modules => [state_server]},
    #{id => sup_workers,
      start => {supervisor_workers, start_link,
       [Id, Server_name, Rules_worker_name, HB_name]},
      restart => permanent,
      shutdown => infinity,
      type => supervisor,
      modules => [supervisor_workers]},
    #{id => comm_ambiente,
      start => {comm_ambiente, start_link, 
       [Comm_ambiente_name, Server_name, Rules_worker_name, HB_name, Id]},
      restart => permanent,
      shutdown => infinity,
      type => worker,
      modules => [comm_ambiente]}
  ],
  {ok, {SupFlags, ChildSpecs}}.
\end{minted}


\chapter{Heartbeat}\label{code:heartbeat}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{erlang}
-record(hb_state, {
  id,                %il mio id
  hb_name,           %il mio hearbeat
  server_name,       %il mio state server 
  neighb_clocks,     %mappa dei vicini
  neighb_state,      %mappa dello stato dei vicini
  i_am_root,         %se sono la root true
  is_root_alive,     %se la radice è viva è true
  oldroot            %se la radice è morta per un po non posso riaccettarla
}).

start_link(Id, Server_name, HB_name) ->
  Pid = spawn_link(?MODULE, init, [Id, Server_name, HB_name]),
  {ok, Pid}.

init(Id, Server_name, HB_name) ->
  register(HB_name, self()),
  State = #hb_state{id = Id, hb_name = HB_name, server_name = Server_name},
  {ok, Clock} = state_server:get_clock(Server_name),
  case Clock of
    -1 ->
      receive
        {neighb_ready} -> % aspetto che il mio comm_ambiente abbia aggiornato la lista dei vicini
          ok
      end;
    _ -> ok
  end,
  {ok, Neighbs} = state_server:get_neighb_hb(Server_name),
  case {Clock, Neighbs} of
    {-1, []} -> % siamo gli unici nella rete
      state_server:update_clock(Server_name, 0),
      Neighbs_clocks = maps:new();
    {-1, _} -> %non ho ancora controllato i vicini
      Neighbs_clocks = enter_network(Neighbs, State);
    _ -> %il supervisor mi ha resuscitato
      Neighbs_clocks = maps:from_list([{Node, -1} || Node <- Neighbs])
  end,
  Neighbs_state = maps:from_list([{Key, alive} || Key <- maps:keys(Neighbs_clocks)]),
  % fingo la fine di un timer per dare inizio al protocollo, essendo is_root_alive inizializzato a false
  self() ! {start_tree},    %parto con l'albero
  self() ! {start_echo},    %parto con gli echo
  listen(State#hb_state{neighb_clocks = Neighbs_clocks,
                        neighb_state = Neighbs_state, 
                        i_am_root = false, 
                        is_root_alive = false, 
                        oldroot = undefined}).

[...]

enter_network(Neighbs, _State = #hb_state{id = Id, hb_name = HB_name, server_name = Server_name}) ->
  spawn(hb_OUT, init, [Server_name, {add_new_nd, Id, HB_name}, Neighbs]), % invia un messaggio ad ogni vicino maybe raggiungibile

  Neighbs_clocks = maps:from_list([{Node, -1} || Node <- Neighbs]),  % crea una mappa per il salvataggio del clock dei vicini
  New_neighbs_clocks = wait_for_all_neighbs(Neighbs_clocks, Server_name),
  check_clock_values(New_neighbs_clocks, HB_name, Server_name),
  New_neighbs_clocks.

[...]

    {add_new_nd, Id_sender, Id_hb_sender} ->
%%      io:format("~p: Ricevuta richiesta connessione alla rete di ~p.~n", [Id, Id_sender]),
      state_server:add_neighb(Server_name, {Id_sender, Id_hb_sender}),
      {ok, Clock} = state_server:get_clock(Server_name),
      try
        Id_hb_sender ! {add_new_nb, HB_name, Clock}
      catch
        _:_ -> ok
      end,
% aggiorno le due mappe usate presenti nello stato
      New_NC = maps:put(Id_hb_sender, Clock, NC),
      New_NS = maps:put(Id_hb_sender, alive, NS),
      listen(State#hb_state{neighb_clocks = New_NC, neighb_state = New_NS});

[...]

    {start_tree} ->
      io:format("~p: Sono entrato in start_tree.~n", [Id]),
      {ok, {Id_root, Dist, _ID_RP}} = state_server:get_tree_state(Server_name),
      {ok, Neighbs_hb} = state_server:get_neighb_hb(Server_name),
      spawn(hb_OUT, init, [Server_name, {tree_state, HB_name, {Id_root, Dist, Id}}, Neighbs_hb]),
      if
        Id_root == Id ->
          New_Im_root = true,
          self() ! {tree_root_keep_alive_timer_ended};
        true ->
          New_Im_root = false
      end,
      listen(State#hb_state{i_am_root = New_Im_root, is_root_alive = false});
[...]

    {tree_state, HB_sender, {Id_root, Dist, Id_sender}} -> % messaggio di aggiornamento della radice dell'albero
      io:format("~p: Ricevuto tree_state: ~p.~n", [Id, {Id_root, Dist, Id_sender}]),
      {ok, {Saved_root, Saved_dist, Saved_RP}} = state_server:get_tree_state(Server_name),
      {ok, Neighbs_map} = state_server:get_neighb_map(Server_name), % mappa con elementi {Id_nodo -> HB_nodo}
      Neighbs_hb = maps:values(Neighbs_map),
      if
        Saved_root < Id_root ->
          spawn(hb_OUT, init, [Server_name, {tree_state, HB_name, {Saved_root, Saved_dist, Id}}, [HB_sender]]),
          New_Im_root = Im_root,
          New_is_alive = Root_alive;
        (Saved_root == Id_root) andalso (Saved_dist + 1 < Dist) ->
          spawn(hb_OUT, init, [Server_name, {tree_state, HB_name, {Saved_root, Saved_dist, Id}}, [HB_sender]]),
          New_Im_root = Im_root,
          New_is_alive = Root_alive;
        (Saved_root > Id_root) andalso (Oldroot =/= Id_root) ->
          % aggiorno lo lo stato dell'albero salvato
          state_server:set_tree_state(Server_name, {Id_root, Dist + 1, Id_sender}),
% avviso la nuova route port che la uso come tale
          spawn(hb_OUT, init, [Server_name, {tree_ack, Id}, [HB_sender]]),
% avviso la vecchia route port che non la uso più
          if
            Saved_RP == Id ->
              ok;
            true ->
              spawn(hb_OUT, init, [Server_name, {tree_rm_rp, Id}, [maps:get(Saved_RP, Neighbs_map)]])
          end,
% avviso i vicini che ho cambiato porta
          spawn(hb_OUT, init, [Server_name, 
              {tree_state, HB_name, {Id_root, Dist + 1, Id}},
              Neighbs_hb -- [HB_sender]]),
          New_Im_root = false,
          New_is_alive = false,
          erlang:send_after(4000, self(), {tree_keep_alive_timer_ended, Id_root});
        ((Saved_root == Id_root) andalso (Saved_dist > Dist + 1))
          orelse
          ((Saved_root == Id_root) andalso (Saved_dist == Dist + 1) andalso (Id_sender < Saved_RP)) ->
% aggiorno lo lo stato dell'albero salvato
          state_server:set_tree_state(Server_name, {Id_root, Dist + 1, Id_sender}),
% avviso la nuova route port che la uso come tale
          spawn(hb_OUT, init, [Server_name, {tree_ack, Id}, [HB_sender]]),
% avviso la vecchia route port che non la uso più
          spawn(hb_OUT, init, [Server_name, {tree_rm_rp, Id}, [maps:get(Saved_RP, Neighbs_map)]]),
% avviso i vicini che ho cambiato porta
          spawn(hb_OUT, init, [Server_name, 
              {tree_state, HB_name, {Id_root, Dist + 1, Id}}, 
              Neighbs_hb -- [HB_sender]]),
          New_Im_root = false,
          New_is_alive = Root_alive;
        true ->
          New_Im_root = Im_root,
          New_is_alive = Root_alive
      end,
      listen(State#hb_state{i_am_root = New_Im_root, is_root_alive = New_is_alive});
\end{minted}

\chapter{Struttura delle regole}\label{code:rulesstruct}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{ini}
File di esempio e spiegazione regole

Variabili:
[
   {var,val}: variabile, valore iniziale
   [...]
}

REGOLA LOCALE
{
    TIPO:
        local: regola che fa qualcosa solo nel nodo
    ,
    TRIGGER: eventi che servono per attivare la regola
    [
        var1, var2, var3,...
    ]
    ,
    CONDIZIONI:
    {
        COND:
            op         : operazione della condizione (lt, lte, gt, gte, eq, neq)
            var1, var2 : variabili di stato coinvolte
        OR             **forse lo implementiamo**
            binop            : {and,or,not}
            {COND1}, {COND2} : lista di cond
    },
    AZIONE:
    [ {var,val} ] : che variabile deve essere settata a cosa
}

REGOLA GLOBALE/TRANSAZIONE
{
    TIPO:
        global:      regola che si propaga nella rete
        transaction: regola che chiede di eseguire qualcosa assieme
    ,
    TRIGGER: eventi che servono per attivare la regola
    [
        var1, var2, var3,...
    ]
    ,
    CONDIZIONI:
    {
        COND:
            op         : operazione della condizione (lt, lte, gt, gte, eq, neq)
            var1, var2 : variabili di stato coinvolte
        OR             **forse lo implementiamo**
            binop            : {land,lor,lnot}
            {COND1}, {COND2} : lista di cond
    },
    AZIONE:
    {
        { GUARDIE }: condizioni di guardia per l'esecuzione delle azioni descritte successivamente
        [ {var,val} ] : che variabile deve essere settata a cosa

        GUARDIE: come condizioni, ma le operazioni sono (lt, lte, gt, gte, eq, neq, tpe, ntp)
    }
}
\end{minted}

\chapter{Memoria dei parametri}\label{code:stateserver}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{erlang}
%% API
-export([start_link/3]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

%% client functions
-export([exec_action/3, exec_action_from_local_rule/3, check_rule_cond/3, check_trans_guard/3]).
-export([update_clock/2, get_clock/1, get_rules/1]).
-export([get_neighb/1, get_neighb_hb/1, add_neighb/2, add_neighbs/2, rm_neighb/2, rm_neighb_with_hb/2, check_neighb/2, get_neighb_map/1]).
-export([get_tree_state/1, reset_tree_state/1, set_tree_state/2, set_tree_active_port/2, rm_tree_active_port/2]).
-export([get_active_neighb/1, get_active_neighb_hb/1]).
-export([ignore_neighb/2, get_ignored_neighb_hb/1]).

-record(server_state, {
  id,
  vars_table,
  rules_table,
  neighb_table,
  node_params_table,
  lost_connections
}).

%%%===================================================================
%%% API
%%%===================================================================

start_link(Name, Id, State_tables) when is_atom(Name) ->
  gen_server:start_link({local, Name}, ?MODULE, [Id, State_tables], []);

[...]

check_condition(Cond, VT, PT) ->
  case Cond of      %operazioni binarie
    {} ->
      true;
    {Op, Var1, Var2} -> % operazioni di arità 2: lt, lte, gt, gte, eq, neq
      % nel caso in cui le variabili siano atomi (quindi vere e proprie variabili) 
      %devo ottenere il valore corrispondente
      % altrimenti sono dei semplici numeri e quindi li uso così come sono
      Real_var1 = if
                    is_atom(Var1) ->
                      [{Var1, Var1_value, _Var1_clock}] = ets:lookup(VT, Var1),
                      Var1_value;
                    true ->
                      Var1
                  end,
      Real_var2 = if
                    is_atom(Var2) ->
                      [{Var2, Var2_value, _Var2_clock}] = ets:lookup(VT, Var2),
                      Var2_value;
                    true ->
                      Var2
                  end,
      % ritorna il valore corrispondente all'operazione eseguita sulle variabili
      case Op of
        lt ->
          Real_var1 < Real_var2;
        lte ->
          Real_var1 =< Real_var2;
        gt ->
          Real_var1 > Real_var2;
        gte ->
          Real_var1 >= Real_var2;
        eq ->
          Real_var1 == Real_var2;
        neq ->
          Real_var1 =/= Real_var2;
%%        land ->
%%          check_condition(Real_var1,VT,PT) andalso check_condition(Real_var2,VT,PT);
%%        lor ->
%%          check_condition(Real_var1,VT,PT) orelse check_condition(Real_var2,VT,PT);
        _ ->
          io:format("State server - check_condition condizione non riconosciuta: ~p.~n", [Cond]),
          false
      end;
    {OpU, Tpc} ->         %operazioni unarie
      case OpU of
        tpe ->
          [{tipo, Tpc}] == ets:lookup(PT, tipo);
        ntp ->
          [{tipo, Tpc}] =/= ets:lookup(PT, tipo);
%%        lnot ->
%%          Real_var1 = if
%%                        is_atom(Var1) ->
%%                          [{Var1, Var1_value, _Var1_clock}] = ets:lookup(VT, Var1),
%%                          Var1_value;
%%                        true ->
%%                          Var1
%%                      end,
%%          check_condition(Real_var1, VT, PT);
        _ ->
          io:format("State server - check_condition condizione non riconosciuta: ~p.~n", [Cond]),
          false
      end;
    _ ->
      io:format("State server - check_condition condizione non riconosciuta: ~p.~n", [Cond]),
      false
  end.
\end{minted}

\chapter{Ambiente}\label{code:ambiente}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{erlang}
[...]
init([GraphFile]) ->
  {ok, [Types, GraphList]} = file:consult(GraphFile),
  CF = utils:check_graph(Types, GraphList),
  if
    CF ->
      ambiente ! {start_nodes};
    true ->
      io:format("Errore nel grafo descritto in ~p.~n", [GraphFile])
  end,
  Graph = ets:new(graph, [
    set,
    public,
    {keypos, 1},
    {heir, none},
    {write_concurrency, false},
    {read_concurrency, true},
    {decentralized_counters, false}
  ]),
  ets:insert(Graph, GraphList),
  process_flag(trap_exit, true),
  {ok, #ambiente_state{graph = Graph, id_spwn = maps:new(), comm_spwn = maps:new(), id_sup_node = maps:new()}}.

[...]

handle_info({start_nodes}, 
    State = #ambiente_state{graph = Graph, 
  id_sup_node = LSN}) ->
  NewLSN = lists:foldr(
    fun(_Node = {Id, Tp, _}, Map) ->
      {ok, Pid} = supervisor_nodo:start_link(Id, Tp),
      maps:put(Id, Pid, Map)
    end,
    LSN,
    ets:tab2list(Graph)),
  {noreply, State#ambiente_state{id_sup_node = NewLSN}};
handle_info({nodo_avviato, Name, {Id, HB_name}}, 
            State = #ambiente_state{graph = Graph, id_spwn = ID_Spwn, comm_spwn = Comm}) ->
  [[NeightboardsList]] = ets:match(Graph, {Id, '_', '$1'}),
  NBL = [{Node, maps:get(Node, ID_Spwn)} || Node <- NeightboardsList, maps:is_key(Node, ID_Spwn)],
  Name ! {discover_neighbs, NBL},
  % controllo della constistenza del grafo
  lists:foreach(fun(Node) ->
    [{IdN, Tpe, NBlist}] = ets:lookup(Graph, Node),
    NNBlist = ((NBlist -- [Id]) ++ [Id]),
    ets:insert(Graph, {IdN, Tpe, NNBlist})
                end,
    NeightboardsList
  ),
  {noreply, State#ambiente_state{id_spwn = maps:put(Id, HB_name, ID_Spwn), 
                                 comm_spwn = maps:put(Id, Name, Comm)}};
\end{minted}

\chapter{Comunicazioni dall'ambiente}\label{code:commambiente}
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos=true, %samepage=true
]{erlang}
[...]

init([Name, Server_name, Rules_worker_name, HB_name, Id]) ->
 % IMPORTANTE: l'ambiente deve essere registrato sotto il nome "ambiente"
  ambiente ! {nodo_avviato, Name, {Id, HB_name}},
  self() ! {start_discovery},
  {ok, #comm_ambiente_state{name = Name,
                            server_name = Server_name,
                            rules_worker_name = Rules_worker_name, 
                            hb_name = HB_name}}.

[...]

handle_info({start_discovery}, State = #comm_ambiente_state{server_name = SN, hb_name = HBN}) ->
  % richiedo all'ambiente di inviarmi la lista dei vicini
  receive
    {discover_neighbs, _Neighbs_list = []} ->
      ok;
    {discover_neighbs, Neighbs_list = [_ | _]} ->
      io:format("Ricevuta lista di vicini: ~p.~n", [Neighbs_list]),
      state_server:add_neighbs(SN, Neighbs_list)
  end,
  HBN ! {neighb_ready},
  {noreply, State};

[...]
\end{minted}

\end{document}
